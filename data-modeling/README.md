### [1. 데이터 모델링의 이해](#1-데이터-모델링의-이해)

[데이터 모델의 이해](#데이터-모델의-이해) </br>
[엔터티](#엔터티) </br>
[속성](#속성) </br>
[관계](#관계) </br>
[식별자](#식별자) </br>

### [2. 데이터 모델과 성능](#2-데이터-모델과-성능)

[성능 데이터 모델링의 개요](#성능-데이터-모델링의-개요) </br>
[정규화와 성능](#정규화와-성능) </br>
[반정규화와 성능](#반정규화와-성능) </br>
[대량 데이터에 따른 성능](#대량-데이터에-따른-성능) </br>
[데이터베이스 구조와 성능](#대량-데이터에-따른-성능) </br>
[분산 데이터베이스와 성능](#분산-데이터베이스와-성능) </br>

---

</br></br>

# 1. 데이터 모델링의 이해

<b>모델링</b>은 현실세계를 일정한 형식에 맞추어 표현하는 `추상화`와
복잡한 현실을 제한된 언어와 표기법을 사용하여 이해하기 쉽게 하는 `단순화`, 애매모호함을 배제하고 누구나 이해가 가능하도록 정확하게 현상을 기술하는 `정확화`의 의미를 가진다.

    단지 시스템 구현만을 위해 수행되는 것이 아닌 시스템 구현을 포함한 업무분석 및 업무형상화를 하는 목적을 위해 수행된다.

## 데이터 모델의 이해

#### ✅ 데이터 모델링의 주된 목적

- 업무정보를 구성하는 기초가 되는 정보들에 대해 일정한 표기법에 의해 표현함으로써 정보시스템 구축의 대상이 되는 업무 내용을 정확하게 분석
- 분석된 모델을 가지고 실제 데이터베이스를 생성하여 개발 및 데이터관리에 사용
- 데이터 모델링 자체로서 업무를 설명하고 분석

#### ✅ 데이터 모델링을 할 때 유의 사항

- <b>중복성(Duplication)</b></br>
  데이터베이스가 여러 장소에 같은 정보를 저장하지 않도록 해야 한다.
- <b>비유연성(Inflexibility)</b></br>
  데이터 모델을 어떻게 설계했는지에 따라 사소한 업무변화에도 데이터 모델이 수시로 변경되어 유지보수의 어려움을 가중시킬 수 있다.</br>
  데이터의 정의를 데이터의 사용 프로세스와 분리하여 데이터 혹은 프로세스의 작은 변화가 애플레케이션과 데이터베이스에 중대한 변화를 일으킬 수 있는 가능성을 줄인다.
- <b>비일관성(Inconsistency)</b></br>
  데이터의 중복이 없더라도 비일관성은 발생할 수 있다. 따라서 데이터와 데이터 간의 상호 연관 관계에 대해 명확하게 정의해야 한다. </br> 사용자가 처리하는 프로세스 혹은 이와 관련된 프로그램과 테이블의 연계성을 높이는 것은 데이터 모델이 업무 변경에 대해 취약하게 만든다.

#### ✅ 데이터 모델링의 개념

데이터모델링은 통합관점의 뷰를 가지는 개념 스키마를 만들어가는 과정이다.

#### ✅ 데이터 모델링

|                      |                                                                                                          |
| :------------------- | :------------------------------------------------------------------------------------------------------- |
| 개념적 데이터 모델링 | 추상화 수준이 높고 업무중심적이고 포괄적인 수준의 모델링 진행. 전사적 데이터 모델링, EA 수립시 많이 이용 |
| 논리적 데이터 모델링 | 시스템으로 구축하고자 하는 업무에 대해 Key, Attribute, Relationship 등을 정확하게 표현, 재사용성이 높음  |
| 물리적 데이터 모델링 | 실제로 데이터베이스에 이식할 수 있도록 성능, 저장 등 물리적인 성격을 고려하여 설계                       |

#### ✅ 데이터베이스 스키마 구조

데이터베이스 스키마 구조는 3단계로 구분되고 각각은 상호 독립적인 의미를 가지며 고유한 기능을 가진다.
| | |
| :-- | :-- |
|외부(External)|the conceptual structure of part of a database(=View)
|개념(Conceptual)|모든 사용자 관점을 통합한 조직 전체 관점의 통합적 표현 </br> 모든 응용시스템들이나 사용자들이 필요로 하는 데이터를 통합한 조직 전체의 DB를 기술한 것으로 DB에 저장되는 데이터와 그들 간의 관계를 표현하는 스키마|
|내부(Internal)|physical storage structure of database </br> Logical Schema와 Physical Schema로 구성|

#### ✅ ERD (Entity Relationship Diagram)

- 1976년 피터첸에 의해 E-R Model 표기법이 만들어졌다.
- ERD 작성 순서 </br>
  엔터티 도출 → 엔터티 배치 → 엔터티간 관계 설정 → 관계명 기술 → 관계의 참여도 기술 → 관계의 필수여부 기술
- 데이터모델링에서 가장 중요한 엔터티를 왼쪽 상단에 배치하고 이를 중심으로 다른 엔터티를 나열하면서 전개하면 시작적으로 편리한 데이터 모델을 작성할 수 있다. 또한 향후 관련 엔터티와 관계선을 연결할 때 선이 꼬이지 않고 효과적으로 배치할 수 있다.

## 엔터티

#### ✅ 엔터티의 특징

- 반드시 해당 업무에서 필요하고 관리하고자 하는 정보여야 한다.
- 유일한 식별자에 의해 식별이 가능해야 한다.
- 영속적으로 존재하는 두 개 이상의 인스턴스의 집합이여야 한다.
- 엔터티는 업무 프로세스에 의해 이용되어야 한다.
- 엔터티는 반드시 속성이 있어야 한다.
- 엔터티는 다른 엔터티와 최소 한 개 이상의 관계가 있어야 한다. </br> (단 통계성 엔터티나 코드성 엔터티의 경우 관계를 생략할 수 있다.)

#### ✅ 엔터티의 분류

| 유무형에 따른 분류 |      설명       |       예시       |
| :----------------: | :-------------: | :--------------: |
|        유형        |   물리적 형태   | 사원, 물품, 강사 |
|        개념        |   개념적 정보   |  조직, 보험상품  |
|        사건        | 업무수행시 발생 | 주문, 청구, 미납 |

| 발생시점에 따른 분류 |                                                                                              |          예시          |
| :------------------: | :------------------------------------------------------------------------------------------- | :--------------------: |
|       기본/키        | 그 업무에 원래 존재하는 정보 </br> 타 엔터티의 부모 역할 </br> 자신의 고유한 주식별자를 가짐 |       사원, 부서       |
|         중심         | 기본 엔터티로부터 발생 </br> 다른 엔터티와의 관계로 많은 행위 엔터티 생성                    |    계약, 사고, 주문    |
|         행위         | 2개 이상의 부모 엔터티로부터 발생 </br> 자주 바뀌거나 양이 증가                              | 주문목록, 사원변경이력 |

#### ✅ 엔터티의 명칭부여

- 가능하면 현업업무에사 사용하는 용어를 사용한다.
- 가능하면 약어를 사용하지 않는다.
- 단수 명사를 사용한다.
- 모든 엔터티를 통틀어 유일하게 이름이 부여되어야 한다.
- 엔터티 생성 의미대로 이름을 부여한다.

## 속성

    업무에서 필요로 하는 인스턴스에서 관리하고자 하는 의미상 더 이상 분리되지 않는 최소의 데이터 단위

- 엔터티에 대한 자세하고 구체적인 정보를 나타낸다
- 하나의 엔터티는 두 개 이상의 속성을 갖는다
- 하나의 인스턴스에서 각각의 속성은 한 개의 속성값을 갖는다
- 속성도 집합이다
- 도메인: 속성에 대한 데이터 타입, 크기, 제약사항을 지정

#### ✅ 속성의 특성에 따른 분류

|          |                                                                                                    |
| :------- | :------------------------------------------------------------------------------------------------- |
| 기본속성 | 업무로부터 추출한 모든 일반적인 속성                                                               |
| 설계속성 | 업무를 규칙화하기 위해 새로 만들거나 정의하는 속성                                                 |
| 파생속성 | 다른 속성에 영향을 받아 발생하며 빠른 성능을 위해 원래 속성의 값을 계산하는 속성으로 적을수록 좋다 |

#### ✅ 속성의 명칭부여

- 해당업무에서 사용하는 이름을 부여
- 서술식 속성명은 사용하지 않음
- 약어 사용은 가급적 제한
- 전체 데이터모델에서 유일성 확보하는 것이 좋음

## 관계

    엔터티의 인스턴스 사이의 논리적인 연관성으로서 존재의 형태로서나 행위로서 서로에게 연관성이 부여된 상태로 관계 페어링의 집합

- 관계는 존재에 의한 관계와 행위에 의한 관계로 구분된다. </br>
  → ERD에서는 관계를 연결할 때, 존재와 행위를 구분하지 않고 단일화된 표기법을 사용한다. </br>
  → UML의 클래스다이어그램은 연관관계와 의존관계가 있고 실선과 점선의 표기법으로 다르게 표현한다.
- 관계 표기법은 관계명(Membership), 관계차수(Cardinality/Degree), 선택사양(Optionality)의 3가지 개념으로 표현한다.

#### ✅ 관계를 체크하는 사항

- 두 개의 엔터티 사이에 관심있는 연관규칙이 존재하는가?
- 두 개의 엔터티 사이에 정보의 조합이 발생하는가?
- 업무기술서, 장표에 관계연결을 가능케 하는 동사(Verb)가 있는가?
- 업무기술서, 장표에 관계연결에 대한 규칙이 서술되어 있는가?

## 식별자

    엔터티 내에서 인스턴스를 구분하는 구분자로 식별자는 논리적, Key는 물리적 데이터 모델링 단계에 사용된다.

#### ✅ 식별자의 특징

|        |                                                                            |
| :----- | :------------------------------------------------------------------------- |
| 유일성 | 주식별자에 의해 모든 인스턴스들이 유일하게 구분                            |
| 최소성 | 주식별자를 구성하는 속성의 수는 유일성을 만족하는 최소의 수가 되어야 함    |
| 불변성 | 지정된 주식별자의 값은 자주 변하지 않아야 함. 변하는 경우 이전 기록 말소됨 |
| 존재성 | 주식별자가 지정되면 반드시 값이 들어와야 함                                |

#### ✅ 식별자의 종류

- 엔터티 내에서 대표성을 가지는가? </br>
  → 주식별자: 엔터티 내에서 각 어커런스를 구분할 수 있는 구분자로 타 엔터티와 참조관계를 연결 </br>
  → 보조식별자: 구분자이나 대표성을 가지지 않으며 참조관계로 연결되지 않는다

- 엔터티 내에서 스스로 생성되었는가? </br>
  → 내부식별자: 스스로 생성되는 식별자 </br>
  → 외부식별자: 타 엔터티로부터 받아오는 식별자

- 단일 속성으로 식별이 되는가? </br>
  → 단일식별자: 하나의 속성으로 구성</br>
  → 복합식별자: 두 개 이상의 속성으로 구성

- 원래 업무적으로 의미가 있던 식별자 속성을 대체하여 일련번호와 같이 새롭게 만들었는가?</br>
  → 본질식별자: 업무에 의해 만들어지는 식별자</br>
  → 인조식별자: 업무적으로 만들어지지는 않지만 원조식별자가 복잡한 구성을 가지고 있기 때문에 인위적으로 만든 식별자

#### ✅ 주식별자의 도츌 기준

- 해당 업무에서 자주 이용되는 속성을 주식별자로 지정한다.
- 명칭, 내역 등과 같이 이름으로 기술되는 것들은 가능하면 주식별자로 지정하지 않는다.
- 복합으로 주식별자를 구성할 경우 너무 많은 속성이 포함되지 않도록 한다.
- 자주 수정되는 속성이 주식별자가 되면 자식 엔터티에 대한 연쇄 수정이 필요하여 시스템 부하의 원인이 될 수 있으므로 주식별자로 지정하지 않는다.

#### ✅ 식별자와 비식별자관계 비교

| 항목               | 식별자관계                                                                                                                  | 비식별자관계                                                                                                                                                                            |
| :----------------- | :-------------------------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 목적               | 강한 연결관계 표현                                                                                                          | 약한 연결관계 표현                                                                                                                                                                      |
| 자식 주식별자 영향 | 자식 주식별자 구성에 포함됨                                                                                                 | 자식 일반 속성에 포함됨                                                                                                                                                                 |
| 표기법             | 실선 표현                                                                                                                   | 점선 표현                                                                                                                                                                               |
| 연결 고려사항      | 반드시 부모 엔터티 종속 </br> 자식 주식별자구성에 부모 주식별자 포함 필요</br> 상속받은 주식별자속성을 타엔터티에 이전 필요 | 약한 종속관계</br>자식주식별자 구성을 독립적으로 구성</br>자식 주식별자구성에 부모 주식별자 부분 필요</br>상속받은 주식별자속성을 타 엔터티에 차단필요</br>부모쪽의 관계참여가 선택관계 |

# 2. 데이터 모델과 성능

## 성능 데이터 모델링의 개요

    성능데이터모델링이란?
    - 데이터베이스 성능 향상을 목적으로 설계단계의 데이터 모델링 때부터 성능과 관련된 사항(정규화, 반정규화, 테이블통합, 테이블분할, 조인구조, PK, FK 등)이 데이터 모델링에 반영될 수 있도록 하는 것

- 데이터의 증가가 빠를수록 성능저하에 따른 성능개선비용은 증가한다.
- 데이터모델은 성능을 튜닝하면서 변경이 될 수 있는 특징이 있다.
- 분석/설계 단계에서 성능을 고려한 데이터모델링을 수행할 경우 성능 저하에 따른 Rework 비용을 최소화할 수 있는 기회를 갖는다
- 어떤 트랜잭션이 해당 비즈니스 처리에 핵심적이고 사용자 업무처리에 있어서 중요하며 성능이 저하되면 안되는 특징을 지닌다면, 프로젝트 초기에 운영환경에 대비한 테스트 환경을 구현하고 그곳에 트랜잭션을 발생시켜 실제 성능을 테스트해봐야 한다.

#### ✅ 성능을 고려한 데이터 모델링의 순서

1. 데이터 모델링을 할 때 정규화를 정확하게 수행한다.
2. 데이터베이스 용량산정을 수행한다.
3. 데이터베이스에 발생되는 트랜잭션의 유형을 파악한다.
4. 용량과 트랜잭션의 유형에 따라 반정규화를 수행한다.
5. 이력모델의 조정, PK/FK조정, 슈퍼타입/서브타입 조정 등을 수행한다.
6. 성능 관점에서 데이터 모델을 검증한다.

- 용량산정은 전체적인 데이터베이스에 발생되는 트랜잭션의 유형과 양을 분석하는 자료가 되므로 성능 데이터 모델링 단계에서 중요하다.
- 물리적 데이터 모델링을 할 때 PK/FK의 칼럼의 순서조정, FK인덱스 생성 등은 성능향상을 위한 작업에서 중요하다.
- 이력데이터는 시간에 따라 반복적으로 발생하기 때문에 대량 데이터일 가능성이 높아 특별히 성능을 고려하여 칼럼을 추가하도록 설계해야 한다.

## 정규화와 성능

    정규화는 기본적으로 중복된 데이터를 제거함으로써 조회성능을 향상시킬 수 있다.

`1차 정규화`: <b>같은 성격, 내용 칼럼이 연속</b>되는 경우에 수행</br>
📍 로우 단위의 중복과 칼럼 단위의 중복의 경우 모두 `1차 정규화` 대상이다. </br>
`2차 정규화`: <b>부분 함수 종속</b>인 경우에 수행 </br>
`3차 정규화`: <b>이행적 함수 종속</b>인 경우에 수행 </br>

## 반정규화와 성능

    반정규화는 정규화된 엔터티(테이블), 속성, 관계에 대해 시스템의 성능향상과 개발과 운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링 기법이다.

    데이터를 중복하여 성능을 향상시키기 위한 기법이며 넓은 의미에서 반정규화는 성능을 향상시키기 위해 정규화된 데이터 모델에서 중복, 통합, 분리 등을 수행하는 모든 과정이다.

    데이터 무결성이 깨질 수 있는 위험에도 불구하고
    1) 데이터를 조회할 때 디스크 I/O량이 많아 성능이 저하되거나
    2) 경로가 너무 멀어 조인으로 인한 성능저하가 예상되거나
    3) 칼럼을 계산하여 읽을 때 성능이 저하될 것으로 예상되는 경우에 반정규화를 수행한다.

- 하나의 결과셋을 추출하기 위해 다량의 데이터를 탐색하는 처리가 반복적으로 빈번하게 발생한다면 반정규화를 고려하는 것이 좋다.
- 이전 또는 이후 위치의 레코드에 대한 탐색은 window function으로 접근 가능하다.
- 집계 테이블 이외에도 다양한 유형(다수 테이블의 키 연결 테이블 등)에 대하여 반정규화 테이블 적용이 필요할 수 있다.

#### ✅ 테이블의 반정규화

|  기법문류  |                                반정규화 기법                                |
| :--------: | :-------------------------------------------------------------------------: |
| 테이블병합 |  1:1 관계 테이블병합</br> 1:M 관계 테이블병합</br>슈퍼/서브타입 테이블병합  |
| 테이블분할 |                            수직분할</br>수평분할                            |
| 테이블추가 | 중복 테이블추가</br>통계 테이블추가</br>이력 테이블추가</br>부분 테이블추가 |

#### ✅ 칼럼의 반정규화

|           반정규화 기법            |
| :--------------------------------: |
|           중복칼럼 추가            |
|           파생칼럼 추가            |
|        이력테이블칼럼 추가         |
|        PK에 의한 칼럼 추가         |
| 응용시스템 오작동을 위한 칼럼 추가 |

#### ✅ 반정규화 절차

|                       |                                                                                               |
| :-------------------: | :-------------------------------------------------------------------------------------------: |
| 1. 반정규화 대상조사  | 범위처리빈도수 조사</br> 대량의 범위처리 조사</br> 통계성 프로세스 조사</br> 테이블 조인 개수 |
| 2. 다른 방법유도 검토 |            View 테이블</br>클러스터링 적용</br>인덱스의 조정</br>응용애플리케이션             |
|   3. 반정규화 적용    |                      테이블 반정규화</br>속성 반정규화</br>관계 반정규화                      |

- 지나치게 많은 조인으로 데이터를 조회하는 작업이 기술적으로 어려울 경우 뷰를 사용한다.
- 대량의 데이터처리나 부분처리에 의해 성능이 저하되는 경우 클럴스터링을 적용하거나 인덱스를 조정하여 성능을 향상시킬 수 있다.
- 대량의 데이터는 PK의 성격에 따라 파티셔닝 기법을 적용하여 테이블로 분리하면 성능저하를 방지할 수 있다.
- 응용애플리케이션에서 로직을 구사하는 방법을 변경하여 성능을 향상시킬 수 있다.

## 대량 데이터에 따른 성능

다량 데이터 탐색의 경우 인덱스가 아닌 파티션 및 클러스터링 등의 다양한 물리 저장 기법을 활용하여 성능 개선을 유도할 수 있다.

하나의 테이블에 많은 양의 데이터가 저장되면 인덱스를 추가하고 테이블을 몇 개로 쪼개도 성능이 저하되는 경우가 있다. 이때 존리적으로는 하나의 테이블이지만 물리적으로 여러 개의 테이블로 분리하여 데이터 액세스 성능도 향상시키고, 데이터 관리 방법도 개선할 수 있도록 테이블에 적용하는 기법을 `Partitioning`이라고 한다.

#### ✅ 슈퍼/서브 타입 데이터 모델의 변환 기술

- `OneToOne Type`: 개별로 발생되는 트랜잭션에 대해서는 개별 테이블로 구성
- `Plus Type`: 슈퍼타입+서브타입에 대해 발생되는 트랜잭션에 대해서는 슈퍼타입+서브타입 테이블로 구성
- `Single Type`, `All in One Type`: 전체를 하나로 묶어 트랜잭션이 발생할 때는 하나의 테이블로 구성
- 각각의 개별 테이블을 모두 조회하는 트랜잭션이 대부분이라는 가정하에 UNION/UNION ALL을 할 경우 개별 조회에 따른 시간소요와 이것을 조합하는 성능저하가 발생된다. 따라서 하나의 테이블로 통합하여 PK체계나 일반속성에 구분자를 부여한다.
- 트랜잭션은 항상 전체를 통합하여 분석처리하는데 슈퍼-서브타입이 하나의 테이블로 통합되어 있으면 하나의 테이블에 집적된 데이터만 읽어 처리할 수 있기 때문에 다른 형식에 비해 성능이 우수(조인 감소)

## 데이터베이스 구조와 성능

- (PK 순서조정) 인덱스는 값의 범위에 따라 일정하게 정렬되어 있으므로 상수값으로 EQUAL 조건으로 조회되는 칼럼을 가장 앞에 오게하고 범위 조회하는 유형의 칼럼을 그 다음으로 오도록 하는 것이 인덱스 액세스 범위를 좁힐 수 있다.
- (FK 인덱스 생성) 데이터베이스 상에서 DBMS가 제공하는 FK Constraints를 생성했는지 여부와 상관없이 조인성능을 향상시키기 위한 인덱스를 생성하는 것이 좋다.

## 분산 데이터베이스와 성능

    여러 곳으로 분산되어 있는 DB를 하나의 가상 시스템으로 사용할 수 있도록 한 DB로 논리적으로 동일한 시스템에 속하지만 컴퓨터 네트워크를 통해 물리적으로 분산되어 있는 데이터 집합이다.

- 공통코드, 기준정보 등 마스터 데이터는 분산데이터베이스에 복제분산을 적용한다
- 거의 실시간 업무적인 특성을 가지고 있을 때 분산 데이터베이스를 사용하여 구성할 수 있다
- 백업 사이트를 구성할 때 간단하게 분산 기능을 적용하여 구성할 수 있다.

#### ✅ 분산 데이터베이스 장단점

|      |                                                                                                                                                                                                                  |
| :--: | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |
| 장점 | 지역 자치성, 점증적 시스템 용량 확장</br>신뢰성과 가용성</br>효용성과 융통성</br>빠른 응답속도와 통신비용 절감</br>데이터의 가용성과 신뢰성증가</br>시스템 규모의 적절한 조절</br>각 지역 사용자의 요구수용 증대 |
| 단점 |                     소프트웨어 개발 비용</br>오류의 잠재성 증대</br>처리 비용 증대 </br> 설계, 관리의 복잡성과 비용 </br> 불규칙한 응답속도</br>통제의 어려움</br>데이터 무결성에 대한 위협                      |

#### ✅ 분산 데이터베이스를 만족하기 위한 6가지 투명성

1. 분할 투명성(단편화): 하나의 논리적 테이블이 여러 단편으로 분할되어 각 사본이 여러 site에 저장
2. 위치 투명성: 사용하려는 데이터의 저장 장소 명시 불필요하며 위치정보가 시스템 카탈로그에 유지
3. 지역사상 투명성: 지역 DBMS와 물리적 DB사이에 매핑을 보장
4. 중복 투명성: DB 객체가 여러 site에 중복되어 있는지 알 필요가 없음
5. 장애 투명성: 구성요소의 장애에 무관한 트랜잭션의 원자성 유지
6. 병행 투명성: 다수 트랜잭션 동시 수행시 결과의 일관성 유지
